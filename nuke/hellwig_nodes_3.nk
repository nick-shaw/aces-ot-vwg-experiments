#! /Applications/Nuke11.1v1/Nuke11.1v1.app/Contents/MacOS/libnuke-11.1.1.dylib -nx
version 11.1 v1
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="23" w="1920" h="1035" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1257" stretch="1"/>
            <splitter orientation="2">
                <split size="593"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="417"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /Users/nick/Dropbox/MacPro_Jobs/AMPAS/output_transforms/Nuke/hellwig_nodes_3.nk
 frame 5
 last_frame 77
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Expression {
 inputs 0
 expr0 "max(0, r)"
 expr1 "max(0, g)"
 expr2 "max(0, b)"
 name neg_clamp
 xpos -318
 ypos -114
}
Read {
 inputs 0
 file /Volumes/RAID_02/ACES_OT_VWG_SampleFrames/ACES_OT_VWG_SampleFrames.####.exr
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 last 77
 origlast 77
 origset true
 name Read2
 xpos -34
 ypos -217
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name ACES_to_XYZ
 xpos -34
 ypos -137
 disable true
}
ColorMatrix {
 matrix {
     {0.9882325471 -0.0078854544 0.0167576355}
     {-0.0056931919 0.9986923398 0.0066723722}
     {0.0003532731 0.0011239769 1.078082949}
   }
 name CAT02_to_D65
 xpos -34
 ypos -99
 disable true
}
Multiply {
 value 100
 name Multiply_100
 xpos -34
 ypos -15
 disable true
}
set N3c8da8a0 [stack 0]
BlinkScript {
 kernelSourceFile /Users/nick/Dropbox/MacPro_Jobs/AMPAS/output_transforms/Nuke/Hellwig.blink
 recompileCount 44
 ProgramGroup 1
 KernelDescription "2 \"HellwigKernel\" iterate pixelWise 962b212c8a8a511bbf3b2321f6bdfec32bbe70e021a3c33a01d4232d90b07911 2 \"src\" Read Point \"dst\" Write Point 16 \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"HK_mode\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"invert\" Bool 1 AA== 16 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"HK_mode\" 1 1 \"compressMode\" 1 1 \"viewingConditions\" 1 1 \"invert\" 1 1 19 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA=="
 kernelSource "kernel HellwigKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n    \n    float3 XYZ_w;\n    float L_A;\n    float Y_b;\n    float3 userSurround;\n    bool discount_illuminant;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode;\n    int compressMode;\n\n    // Viewing Conditions\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n\n    bool invert;\n\n  local:\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n  // In define(), parameters can be given labels and default values.\n  void define() \{\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\nfloat3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  // The init() function is run before any calls to process().\n  // Local variables can be initialized here.\n  void init() \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n  \}\n\n  void process() \{\n    // Read the input image\n    SampleType(src) input = src();\n\n    // Isolate the XYZ components\n    float3 srcPixel(input.x, input.y, input.z);\n\n    float3 dstPixel;\n\n    if(invert)\n    \{\n        dstPixel  = Hellwig2022_JMh_to_XYZ(srcPixel, XYZ_w, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discount_illuminant,HK_mode);\n    \}\n    else\n    \{\n        dstPixel = XYZ_to_Hellwig2022_JMh(srcPixel, XYZ_w, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discount_illuminant,HK_mode);\n    \}\n\n    // Write the result to the output image\n    dst() = float4(dstPixel.x, dstPixel.y, dstPixel.z, input.w);\n  \}\n\};\n"
 rebuild ""
 HellwigKernel_rxy {0.82 0.175}
 HellwigKernel_gxy {-1.3 1.8}
 HellwigKernel_bxy {0.13 -0.1}
 HellwigKernel_wxy {0.333 0.333}
 HellwigKernel_ra 2
 HellwigKernel_ba 0.05
 HellwigKernel_XYZ_w {95.05 100 108.88}
 HellwigKernel_L_A 318.31
 HellwigKernel_Y_b 20
 HellwigKernel_discount_illuminant true
 HellwigKernel_compressMode 1
 HellwigKernel_viewingConditions 1
 rebuild_finalise ""
 name BlinkScript1
 xpos -34
 ypos 29
 disable true
}
set N27d0dd80 [stack 0]
BlinkScript {
 kernelSourceFile /Users/nick/Dropbox/MacPro_Jobs/AMPAS/output_transforms/Nuke/Hellwig.blink
 recompileCount 40
 ProgramGroup 1
 KernelDescription "2 \"HellwigKernel\" iterate pixelWise 962b212c8a8a511bbf3b2321f6bdfec32bbe70e021a3c33a01d4232d90b07911 2 \"src\" Read Point \"dst\" Write Point 16 \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"HK_mode\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"invert\" Bool 1 AA== 16 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"HK_mode\" 1 1 \"compressMode\" 1 1 \"viewingConditions\" 1 1 \"invert\" 1 1 19 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA=="
 kernelSource "kernel HellwigKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n    \n    float3 XYZ_w;\n    float L_A;\n    float Y_b;\n    float3 userSurround;\n    bool discount_illuminant;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode;\n    int compressMode;\n\n    // Viewing Conditions\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n\n    bool invert;\n\n  local:\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n  // In define(), parameters can be given labels and default values.\n  void define() \{\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\nfloat3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  // The init() function is run before any calls to process().\n  // Local variables can be initialized here.\n  void init() \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n  \}\n\n  void process() \{\n    // Read the input image\n    SampleType(src) input = src();\n\n    // Isolate the XYZ components\n    float3 srcPixel(input.x, input.y, input.z);\n\n    float3 dstPixel;\n\n    if(invert)\n    \{\n        dstPixel  = Hellwig2022_JMh_to_XYZ(srcPixel, XYZ_w, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discount_illuminant,HK_mode);\n    \}\n    else\n    \{\n        dstPixel = XYZ_to_Hellwig2022_JMh(srcPixel, XYZ_w, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discount_illuminant,HK_mode);\n    \}\n\n    // Write the result to the output image\n    dst() = float4(dstPixel.x, dstPixel.y, dstPixel.z, input.w);\n  \}\n\};\n"
 rebuild ""
 HellwigKernel_rxy {0.82 0.175}
 HellwigKernel_gxy {-1.3 1.8}
 HellwigKernel_bxy {0.13 -0.1}
 HellwigKernel_wxy {0.333 0.333}
 HellwigKernel_ra 2
 HellwigKernel_ba 0.05
 HellwigKernel_XYZ_w {95.05 100 108.88}
 HellwigKernel_L_A 318.31
 HellwigKernel_Y_b 20
 HellwigKernel_discount_illuminant true
 HellwigKernel_compressMode 1
 HellwigKernel_viewingConditions 1
 HellwigKernel_invert true
 rebuild_finalise ""
 name BlinkScript2
 xpos -160
 ypos 29
}
Multiply {
 value 0.01
 name Div_100
 xpos -160
 ypos 101
}
push $N3c8da8a0
BlinkScript {
 kernelSourceFile /Users/afry/GitHub/hellwig2022/hellwig2022.blink
 recompileCount 251
 ProgramGroup 1
 KernelDescription "2 \"hellwig2022\" iterate pixelWise e61ba9f246a6b79db1f7d548e2d7d9671fb5a58c7be502922ad28c704879b04e 2 \"src\" Read Point \"dst\" Write Point 6 \"direction\" Int 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"surround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== 6 \"direction\" 1 1 \"XYZ_w\" 3 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"surround\" 3 1 \"discount_illuminant\" 1 1 3 \"HALF_MIN\" Float 1 1 AAAAAA== \"HALF_MAX\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
 kernelSource "\nkernel hellwig2022 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n\n    // the kernel parameters\n    int direction; // the direction of the convolution\n\n    float3 XYZ_w;\n    float L_A;\n    float Y_b;\n    float3 surround;\n    bool discount_illuminant;\n\n\n  local:\n    float HALF_MIN;\n    float HALF_MAX;\n\n    float3x3 CAT_CAT16;\n\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n        // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n    // this one initially returned -pow(abs(b), e) for negative b\n    // but this ended up producing undesirable results in some cases\n    // so now it just returns 0.0 instead\n    float spow( float base, float exponent )\n    \{\n        if(base < 0.0f && exponent != floor(exponent) )\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return pow(base, exponent); \n        \}\n    \}\n\n    float3 float3spow( float3 base, float exponent )\n    \{\n        return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n    \}\n\n    float3 float3sign( float3 v )\n    \{\n        return float3(sign(v.x), sign(v.y), sign(v.z));\n    \}\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n\n    // convert radians to degrees\n    float degrees( float radians )\n    \{\n      return radians * 180.0f / PI;\n    \}\n\n    float abs( float a )\n    \{\n      return fabs(a);\n    \}\n\n    float3 float3abs( float3 a )\n    \{\n      return fabs(a);\n    \}\n  \n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n  float3 float3_to_domain_100( float3 v )\n  \{\n    return v;\n  \}\n  \n\n\n  float hue_angle( float a, float b )\n  \{\n    // \"\"\"\n    // Return the *hue* angle :math:`h` in degrees.\n\n    // Parameters\n    // ----------\n    // a\n    //     Opponent colour dimension :math:`a`.\n    // b\n    //     Opponent colour dimension :math:`b`.\n\n    // Returns\n    // -------\n    // :class:`numpy.floating` or :class:`numpy.ndarray`\n    //     *Hue* angle :math:`h` in degrees.\n\n    // Examples\n    // --------\n    // >>> a = -0.000624112068243\n    // >>> b = -0.000506270106773\n    // >>> hue_angle(a, b)  # doctest: +ELLIPSIS\n    // 219.0484326...\n    // \"\"\"\n\n    // a = as_float_array(a);\n    // b = as_float_array(b);\n\n    float h = degrees(atan2(b, a)) / 360;\n\n    return h;\n  \}\n\n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float radians(float a)\n  \{\n    return a * PI / 180.0f;\n  \}\n\n  float achromatic_response_forward(float3 RGB)\n  \{\n    //   \"\"\"\n    //   Return the achromatic response :math:`A` from given compressed\n    //   *CAM16* transform sharpened *RGB* array and :math:`N_\{bb\}` chromatic\n    //   induction factor for forward *Hellwig and Fairchild (2022)* implementation.\n\n    //   Parameters\n    //   ----------\n    //   RGB\n    //       Compressed *CAM16* transform sharpened *RGB* array.\n\n    //   Returns\n    //   -------\n    //   :class:`numpy.floating` or :class:`numpy.ndarray`\n    //       Achromatic response :math:`A`.\n\n    //   Examples\n    //   --------\n    //   >>> RGB = np.array(\[7.94634384, 7.94713791, 7.9488967])\n    //   >>> achromatic_response_forward(RGB)  # doctest: +ELLIPSIS\n    //   23.9322704...\n    //   \"\"\"\n\n    float R = RGB.x;\n    float G = RGB.y;\n    float B = RGB.z;\n\n\n    float A = 2 * R + G + 0.05 * B - 0.305;\n\n    return A;\n  \}\n\n  float colourfulness_correlate(float N_c,float e_t,float a,float b) \n  \{\n    // \"\"\"\n    // Return the *colourfulness* correlate :math:`M`.\n\n    // Parameters\n    // ----------\n    // N_c\n    //     Surround chromatic induction factor :math:`N_\{c\}`.\n    // e_t\n    //     Eccentricity factor :math:`e_t`.\n    // a\n    //     Opponent colour dimension :math:`a`.\n    // b\n    //     Opponent colour dimension :math:`b`.\n\n    // Returns\n    // -------\n    // :class:`numpy.floating` or :class:`numpy.ndarray`\n    //     *Colourfulness* correlate :math:`M`.\n\n    // Examples\n    // --------\n    // >>> N_c = 1\n    // >>> e_t = 1.13423124867\n    // >>> a = -0.00063418423001\n    // >>> b = -0.000479072513542\n    // >>> colourfulness_correlate(N_c, e_t, a, b)  # doctest: +ELLIPSIS\n    // 0.0387637...\n    // \"\"\"\n\n    // N_c = as_float_array(N_c)\n    // e_t = as_float_array(e_t)\n    // a = as_float_array(a)\n    // b = as_float_array(b)\n\n    float M = 43 * N_c * e_t * sqrt(pow(a,2) + pow(b,2));\n\n    return M;\n  \}\n\n\n\n  float degree_of_adaptation(float  F, float L_A )\n    \{\n    // \"\"\"\n    // Return the degree of adaptation :math:`D` from given surround maximum\n    // degree of adaptation :math:`F` and adapting field *luminance* :math:`L_A`\n    // in :math:`cd/m^2`.\n\n    // Parameters\n    // ----------\n    // F\n    //     Surround maximum degree of adaptation :math:`F`.\n    // L_A\n    //     Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`.\n\n    // Returns\n    // -------\n    // :class:`numpy.floating` or :class:`numpy.ndarray`\n    //     Degree of adaptation :math:`D`.\n\n    // Examples\n    // --------\n    // >>> degree_of_adaptation(1.0, 318.31)  # doctest: +ELLIPSIS\n    // 0.9944687...\n    // \"\"\"\n\n    // F = as_float_array(F)\n    // L_A = as_float_array(L_A)\n\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n    \}\n\n\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discount_illuminant)\n    \{\n//     \"\"\"\n//     Compute the *Hellwig and Fairchild (2022)* colour appearance model\n//     correlates from given *CIE XYZ* tristimulus values.\n\n//     Parameters\n//     ----------\n//     XYZ\n//         *CIE XYZ* tristimulus values of test sample / stimulus.\n//     XYZ_w\n//         *CIE XYZ* tristimulus values of reference white.\n//     L_A\n//         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n//         to be 20% of the luminance of a white object in the scene).\n//     Y_b\n//         Luminous factor of background :math:`Y_b` such as\n//         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n//         light source and :math:`L_b` is the luminance of the background. For\n//         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n//         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n//         approximate an :math:`L^*` of 50 is used.\n//     surround\n//         Surround viewing conditions induction factors.\n//     discount_illuminant\n//         Truth value indicating if the illuminant should be discounted.\n\n//     Returns\n//     -------\n//     :class:`colour.CAM_Specification_Hellwig2022`\n//         *Hellwig and Fairchild (2022)* colour appearance model specification.\n\n//     Notes\n//     -----\n//     +------------+-----------------------+---------------+\n//     | **Domain** | **Scale - Reference** | **Scale - 1** |\n//     +============+=======================+===============+\n//     | ``XYZ``    | \[0, 100]              | \[0, 1]        |\n//     +------------+-----------------------+---------------+\n//     | ``XYZ_w``  | \[0, 100]              | \[0, 1]        |\n//     +------------+-----------------------+---------------+\n\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n//     | **Range**                           | **Scale - Reference** | **Scale - \\\n// 1** |\n//     +=====================================+=======================+===========\\\n// ====+\n//     | ``CAM_Specification_Hellwig2022.J`` | \[0, 100]              | \[0, 1]    \\\n//     |\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n//     | ``CAM_Specification_Hellwig2022.C`` | \[0, 100]              | \[0, 1]    \\\n//     |\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n//     | ``CAM_Specification_Hellwig2022.h`` | \[0, 360]              | \[0, 1]    \\\n//     |\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n//     | ``CAM_Specification_Hellwig2022.s`` | \[0, 100]              | \[0, 1]    \\\n//     |\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n//     | ``CAM_Specification_Hellwig2022.Q`` | \[0, 100]              | \[0, 1]    \\\n//     |\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n//     | ``CAM_Specification_Hellwig2022.M`` | \[0, 100]              | \[0, 1]    \\\n//     |\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n//     | ``CAM_Specification_Hellwig2022.H`` | \[0, 400]              | \[0, 1]    \\\n//     |\n//     +-------------------------------------+-----------------------+-----------\\\n// ----+\n\n//     References\n//     ----------\n//     :cite:`Fairchild2022`, :cite:`Hellwig2022`\n\n//     Examples\n//     --------\n//     >>> XYZ = np.array(\[19.01, 20.00, 21.78])\n//     >>> XYZ_w = np.array(\[95.05, 100.00, 108.88])\n//     >>> L_A = 318.31\n//     >>> Y_b = 20.0\n//     >>> surround = VIEWING_CONDITIONS_Hellwig2022\['Average']\n//     >>> XYZ_to_Hellwig2022(XYZ, XYZ_w, L_A, Y_b, surround)\n//     ... # doctest: +ELLIPSIS\n//     CAM_Specification_Hellwig2022(J=41.7312079..., C=0.0257636..., \\\n// h=217.0679597..., s=0.0608550..., Q=55.8523226..., M=0.0339889..., \\\n// H=275.5949861..., HC=None)\n//     \"\"\"\n\n    XYZ = float3_to_domain_100(XYZ);\n    XYZ_w = float3_to_domain_100(XYZ_w);\n    float _X_w = XYZ_w.x ;\n    float Y_w = XYZ_w.y ;\n    float _Z_w = XYZ_w.z ;\n    // L_A = as_float_array(L_A)\n    // Y_b = as_float_array(Y_b)\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3x3 MATRIX_16 = CAT_CAT16;\n    float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n    if(discount_illuminant)\n    \{\n        D = 1.0f;\n    \}\n\n\n    // # Viewing conditions dependent parameters\n    float k = 1 / (5 * L_A + 1);\n    float k4 = pow(k,4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n = sdiv(Y_b, Y_w);\n    float z = 1.48 + sqrt(n);\n\n    // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n    float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    \n    // # Applying forward post-adaptation non-linear response compression.\n    // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n    float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n    // # Computing achromatic responses for the whitepoint.\n    // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n    float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB) + 0.1f;\n\n    // # Computing achromatic responses for the whitepoint.\n    // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n    float R_aw = RGB_aw.x ;\n    float G_aw = RGB_aw.y ;\n    float B_aw = RGB_aw.z ;\n    // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n    float A_w = 2 * R_aw + G_aw + 0.05f * B_aw - 0.305f;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    // RGB = vector_dot(MATRIX_16, XYZ)\n    float3 RGB = vector_dot(MATRIX_16, XYZ);\n\n    // # Step 2\n    // RGB_c = D_RGB * RGB\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n    // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_c) / 100, 0.42)\n    float3 F_L_RGB_2 = float3spow(F_L * float3abs(RGB_c) / 100.0f, 0.42f);\n    // RGB_a = (400 * np.sign(RGB_c) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n    float3 RGB_a = (400.0f * float3sign(RGB_c) * F_L_RGB_2) / (27.13f + F_L_RGB_2) + 0.1f;\n\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    // R_a, G_a, B_a = tsplit(RGB_a)\n    float R_a = RGB_a.x ;\n    float G_a = RGB_a.y ;\n    float B_a = RGB_a.z ;\n    // a = R_a - 12 * G_a / 11 + B_a / 11\n    float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    // b = (R_a + G_a - 2 * B_a) / 9\n    float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    // h = np.degrees(np.arctan2(b, a)) % 360\n    // Unclear why this isnt matching the python version.\n    float h = mod(degrees(atan2(b, a)), 360.0f);\n\n    \n\n    // # Step 5\n    // # Computing eccentricity factor *e_t*.\n    // hr = np.radians(h)\n    float hr = radians(h);\n\n    // _h = hr\n    // _2_h = 2 * hr\n    // _3_h = 3 * hr\n    // _4_h = 4 * hr\n    float _h = hr;\n    float _2_h = 2 * hr;\n    float _3_h = 3 * hr;\n    float _4_h = 4 * hr;\n\n    // e_t = (\n    //     -0.0582 * np.cos(_h)\n    //     - 0.0258 * np.cos(_2_h)\n    //     - 0.1347 * np.cos(_3_h)\n    //     + 0.0289 * np.cos(_4_h)\n    //     - 0.1475 * np.sin(_h)\n    //     - 0.0308 * np.sin(_2_h)\n    //     + 0.0385 * np.sin(_3_h)\n    //     + 0.0096 * np.sin(_4_h)\n    //     + 1\n    // )\n    float e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n    );\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    // R_a, G_a, B_a = tsplit(RGB_a)\n    float R_a2 = RGB_a.x ;\n    float G_a2 = RGB_a.y ;\n    float B_a2 = RGB_a.z ;\n    // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n    float A = 2 * R_a2 + G_a2 + 0.05f * B_a2 - 0.305f;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    // with sdiv_mode():\n    //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n    float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // with sdiv_mode():\n    //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n    float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n    float M = 43.0f * surround.z * e_t * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    // with sdiv_mode():\n    //     C = 35 * sdiv(M, A_w)\n    float C = 35.0f * sdiv(M, A_w);\n\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // with sdiv_mode():\n    //     s = 100 * sdiv(M, Q)\n    float s = 100.0f * sdiv(M, Q);\n\n\n\n    // return XYZ_w;\n    // return RGB_w;\n    // return \{D,k,k4\};\n    // return \{F_L,n,z\};\n    // return RGB_a;\n    return \{J,M,h\};\n    // return XYZ;\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discount_illuminant)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n\n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discount_illuminant)\n        \{\n            D = 1.0f;\n        \}\n\n\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n        \n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB) + 0.1f;\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = 2 * R_aw + G_aw + 0.05f * B_aw - 0.305f;\n\n        // # Step 2\n        // # Computing eccentricity factor *e_t*.\n        // hr = np.radians(h)\n        float hr = radians(h);\n\n\n        // _h = hr\n        // _2_h = 2 * hr\n        // _3_h = 3 * hr\n        // _4_h = 4 * hr\n        float _h = hr;\n        float _2_h = 2 * hr;\n        float _3_h = 3 * hr;\n        float _4_h = 4 * hr;\n    \n        // e_t = (\n        //     -0.0582 * np.cos(_h)\n        //     - 0.0258 * np.cos(_2_h)\n        //     - 0.1347 * np.cos(_3_h)\n        //     + 0.0289 * np.cos(_4_h)\n        //     - 0.1475 * np.sin(_h)\n        //     - 0.0308 * np.sin(_2_h)\n        //     + 0.0385 * np.sin(_3_h)\n        //     + 0.0096 * np.sin(_4_h)\n        //     + 1\n        // )\n        float e_t = (\n            -0.0582f * cos(_h)\n            - 0.0258f * cos(_2_h)\n            - 0.1347f * cos(_3_h)\n            + 0.0289f * cos(_4_h)\n            - 0.1475f * sin(_h)\n            - 0.0308f * sin(_2_h)\n            + 0.0385f * sin(_3_h)\n            + 0.0096f * sin(_4_h)\n            + 1.0f\n        );\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z * e_t;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        // RGB_a = (\n        //     vector_dot(\n        //         \[\n        //             \[460, 451, 288],\n        //             \[460, -891, -261],\n        //             \[460, -220, -6300],\n        //         ],\n        //         tstack(\[P_p_2, a, b]),\n        //     )\n        //     / 1403\n        // )\n\n        float panlrcm_data\[]=\n        \{\n            460.0f, 451.0f, 288.0f,\n            460.0f, -891.0f, -261.0f,\n            460.0f, -220.0f, -6300.0f,\n        \};\n        float3x3 panlrcm;\n        panlrcm.setArray(panlrcm_data);\n\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n        // RGB_c = (\n        //     np.sign(RGB_a)\n        //     * 100\n        //     / F_L\[..., np.newaxis]\n        //     * spow(\n        //         (27.13 * np.absolute(RGB_a)) / (400 - np.absolute(RGB_a)),\n        //         1 / 0.42,\n        //     )\n        // )\n        float3 RGB_c = float3sign(RGB_a) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB_a)) / (400.0f - float3abs(RGB_a)), 1.0f / 0.42f);\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n\n    \}\n\n\n  void init()\n  \{\n    HALF_MIN = 0.0000000596046448f;\n    HALF_MAX = 65504.0f;\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    CAT_CAT16.setArray(CAT_CAT16_data);\n\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n\n    // diagnostic =  srcRGB;\n\n    // float3 surround(1.0f, 0.69f, 1.0f);\n    // float3 XYZ_w(95.05f, 100.00f, 108.88f);\n\n    if (direction == 0)\n    \{\n        float3 JMh = XYZ_to_Hellwig2022_JMh(srcRGB, XYZ_w, L_A, Y_b,surround,discount_illuminant);\n        dstRGB = JMh;\n    \}\n    else\n    \{\n        float3 XYZ_out = Hellwig2022_JMh_to_XYZ(srcRGB, XYZ_w, L_A, Y_b, surround, discount_illuminant);\n        dstRGB = XYZ_out;\n    \}\n\n    diagnostic = dstRGB;\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
 rebuild ""
 hellwig2022_direction 1
 hellwig2022_XYZ_w {95.05 100 108.88}
 hellwig2022_L_A 318.31
 hellwig2022_Y_b 20
 hellwig2022_surround {1 0.69 1}
 rebuild_finalise ""
 name BlinkScript3
 xpos 189
 ypos -15
}
push $N27d0dd80
Multiply {
 value {0.01 0.01 0.002777777778 1}
 name norm_JMh
 xpos -34
 ypos 99
 disable true
}
Viewer {
 inputs 3
 frame 5
 frame_range 1-77
 colour_sample_bbox {0.3177083433 0.150000006 0.318749994 0.1510416716}
 samplepoints {{0.3177083433 0.150000006}
   }
 viewerProcess None
 name Viewer1
 xpos -34
 ypos 174
}
